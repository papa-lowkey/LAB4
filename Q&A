    COMMON QUESTIONS AND ANSWERS
    ----------------------------


    1. Is there still a limit to the size of the code and data
       segments like there was in 3.0?

       The total size of a program's code is only limited by the
       memory you have available; but each unit (module) can be
       no larger than 64K, since it has to have its own code
       segment.

       The data segment is still no more than 64K, but the heap
       is unlimited just as in 3.0. In fact, we've rewritten the
       heap manager to make it much more efficient. There's no
       waste when allocating memory (in 3.0, all blocks were
       rounded up to a factor of 8), and you can install a heap
       error routine that gets called if an allocation request
       fails. All in all, 4.0's heap manager is much faster than
       version 3.0 (see page 339).

    2. Can Turbo Pascal run on generic MS-DOS machines?

       TPC.EXE will run on generic machines when you use the /Q
       option. The System, Dos and Printer standard units will
       operate correctly on MS-DOS generic machines. Generated
       .EXE's are MS-DOS compatible as long as you don't use the
       special PC units (such as Crt, Graph, and Graph3). You may
       not be able to use the 8087 floating- point math package,
       depending on whether your machine has PC-compatible math
       coprocessor support.

    3. Does Turbo Pascal 4.0 support large integers?

       Yes, TP 4.0 has virtually any incarnation of 8-, 16-, and
       32-bit integers: shortint, integer, longint, byte, and
       word (see page 209).

    4. Will the Toolboxes for 3.0 be ported to version 4.0 of Turbo
       Pascal?

       Yes, all toolboxes have been upgraded to work with Turbo
       Pascal 4.0. Contact our customer service department about
       upgrading your toolboxes.

    5. Does Turbo Pascal version 4.0 support any form of conditional
       compilation like Turbo C does?

       Yes, Turbo 4.0 includes conditional compilation support.
       You use {$DEFINE ...} and {$UNDEF ...} for symbols and
       {$IFDEF ...}. Using the {$IFOPT ...} conditional
       directive, you can even test the settings of compiler
       directives like R-, N+, and others. For the command-line
       compiler, you can define symbols with the /D directive. In
       the integrated compiler, you can also define symbols via a
       pull-down menu item (see page 94 and 534).

    6. How much of the 64K in the data segment is actually
       available to my program?

       The amount of data segment used by the run-time library
       depends on which standard units you use in your program.
       Here is the data segment usage (in bytes) for each unit:

             UNIT         Data Size
             ----         ---------
             SYSTEM          585
             DOS               6
             CRT              26
             PRINTER         256
             GRAPH           834
             TURBO3          256
             GRAPH3            0
                          =========
                            1963

       The total size of the data segment is 65520 bytes. If you
       used only the system unit, the amount of data segment
       space left over would be

             65520 - 585 = 64935 bytes

       (see page 293 and 339).

    7. What is the largest global data structure you can
       allocate?

       The maximum size of a single variable that can be
       allocated on the heap is 65521 bytes (see page 340).

    8. How do I find out how much code and data were generated by
       the compiler for a program or unit?

       If you are using the integrated environment, build your
       program or unit and then use the get info command in the
       compile menu. This will bring up a window of information
       about the current program or unit including the size of
       code and data (see page 157).

       If you are using the command line compiler, the size of
       generated code and data is displayed on the screen at the
       end of compilation.

    9. Are the .OBJ files generated by TP 4.0 compatible with Turbo C
       and/or Turbo Prolog?

       You can write assembly language routines and link in .OBJ
       files by using [$L] compiler directives. Turbo Pascal 4.0
       generates .TPU (Turbo Pascal Unit) files, not .OBJ files.
       We've made that decision for many reasons:

         A. TP 4.0's .TPU files are smaller than .OBJ's, and they
            contain symbolic information important to the support
            of pascal's strict type conventions (types,
            constants, etc.).

         B. .TPU files allow "smart linking" - elimination of
            unused code on a procedure-by-procedure basis.

         C. .TPU's allow built-in project management through
            version 4.0's Make and Build commands.

         D. .TPU's allow faster compilation speeds (27,000 lines
            per minute)

       You can link in .OBJ files from Turbo C too. For
       assembler, you can use MASM and A86 (a shareware assembler
       available on Compuserve) (see page 360).

   10. Will the $L compiler directive work for compiler object files
       other than assembler?

       That depends on the language. TURBO requires all the code
       in the .OBJ to be in *one* CODE segment, and all the data
       to be in *one* DATA segment. With assembly language that's
       easy, but it may not work with some high-level language
       compilers (see page 360).

   11. Does the built-in linker link in unused data?

       Yes, all data defined in your program and units will be
       linked in whether it is used or not. The linker only
       strips unused code (see page 350).

   12. If two units use a third unit, does the third unit get
       included twice in my program?

       No. All your units are "linked" together when you compile
       your program. Only one copy of each procedure and function
       used is generated.  There is NO duplication of runtime
       code. In fact, Turbo Pascal 4.0 has "smart linking," which
       eliminates any dead code not used in the final .EXE.

   13. What happens if you attempt to link another unit in which the
       compiler directives are set differently?

       Compiler directives are local to the unit they are
       declared in. Thus, the compiler directives in one unit, or
       in a main program, have no effect on the directives set in
       another unit.

   14. Can I create my own .TPL file?

       Yes, but Turbo Pascal will only use the TURBO.TPL library
       file. If you want to add your own units to the TURBO.TPL
       file, you can use the unit mover program (TPUMOVER.EXE).
       For example, you might want a customized version of
       TURBO.TPL for each of the programs you're developing. A
       corresponding configuration file for Turbo Pascal would
       specify a different Turbo directory and thus fetch the
       appropriate .TPL file for each of your projects (see page
       101).

   15. What rules should I follow when writing an interrupt
       handler?

       The following is a list of rules to keep in mind when
       writing an interrupt handler:

         A. Use GetIntVec and SetIntVec to install/uninstall
            interrupt handlers

         B. Use the interrupt directive

         C. Be careful about reentrancy. Don't use any calls to
            DOS or to Turbo Pascal's heap management routines in
            your interrupt handler

         D. Interrupt procedures and functions must use the far
            call model (use the {$F+} option)

         E. Be proficient with the BIOS and assembly language
            before attempting to write an interrupt handler

       (see page 369).

   16. Does a procedure or function in a program have to be of a
       near or far call model?

       Most programmers never need to worry about memory call
       models because Turbo Pascal automatically selects the
       correct call model.  A routine is always near call model
       unless

        1) it is declared in the interface section of a unit

        2) you override the default call model by using the {$F+}
           compiler option

       You should use the {$F+} option to override the default
       call model if you are writing interrupt handlers, error
       handlers or exit procs (see page 358).

   17. How do I write reentrant code in Turbo Pascal?

       If a routine follows these rules it is reentrant:

         A. All data is allocated on the stack

         B. The routine doesn't use any global variables

         C. The routine can be interrupted at any time without
            affecting the execution of the routine

         D. The routine doesn't call any other routines that are
            not reentrant (eg DOS I/O)

       (see page 369 and 370).

   18. What is the best approach to taking advantage of the new IEEE
       floating-point types?

       The new IEEE floating-point types are only available when
       compiling and running on a machine with a numeric
       coprocessor. If your program will be running on machines
       without the numeric coprocesser, then you can't use the
       new floating-point types (see page 331).

       When developing programs that will be compiled and run on
       machines with and without the 8087 coprocessor, you should
       use a declaration similar to the following one. This
       redefines the standard floating-point identifiers to avoid
       having to maintain two versions of your programs:

       {$IFDEF CPU87}
       {$N+}
       {  if there is a math coprocessor chip, then define   }
       {  the type real to be an IEEE double precision       }
       type
         real     = double;
       {$ELSE}
       {$N-}
       {  if there is no math coprocessor chip, then define  }
       {  the IEEE types to be the same as the Turbo Pascal  }
       {  6 byte real                                        }
       type
         double   = real;
         single   = real;
         comp     = real;
         extended = real;
       {$ENDIF}

   19. What type is comp? What is it useful for?

       The comp type is a cross between an integer and a real
       type. Comp is only available when you have a numeric
       coprocessor chip installed. The compiler treats it as a
       real type without an exponent. Thus comp is useful when
       you need to store extremely large numbers but don't need a
       decimal point. For example, you might use variables of
       type comp to store amounts in cents and divide the value
       of the variable by 100 to determine what the value in
       dollars and cents would be (see page 351).

   20. How many significant digits do the 8087 floating-point types
       provide?

       Type           Digits of precision
       --------       -------------------
       single               7-8
       double              15-16
       extended            19-20
       comp                19-20

   21. Are the intermediate results of real number expressions
       stored in the 8087 registers?

       Yes. When using the 8087 math package, all the intermediate
       results of a real number expression are stored in the 8087
       registers in full 80-bit precision.  See the FIB8087.PAS
       example program that shows you how to avoid 8087 stack
       overflow when doing recursion with floating point (see
       page 335).

   22. How does rounding work with IEEE floating point?

       The 8087 math coprocessor uses a different method for
       rounding numbers than what you may be used to. In order to
       acheive a more even distribution of values, the 8087 uses
       a method sometimes called "Banker's Rounding." This method
       dictates that a number will always be rounded to the
       nearest EVEN number. Note that this is quite different
       than always rounding UP. A couple of examples are:

          Round(0.5) = 0
          Round(1.5) = 2

       (see page 331).

   23. How do you do I/O redirection?

       If you want to do DOS I/O redirection when running an .EXE
       file generated by Turbo Pascal, DON'T use the Crt unit, or
       make sure you assign a text file variable to the standard
       DOS output device.

       Assign(Output,''); { assign a text file variable }
                          { to a null file name         }
       ReWrite(Output);   { do a rewrite here  }

       Any output that you want redirected must now be written to
       the file variable Output.  This will cause output to be
       redirected to the DOS standard output file (see page 383).

   24. How do you go about upgrading version 3.0 programs with
       lots of chain files?

       Chaining is not possible with .EXE files.  Control can be
       passed to another program by use of the EXEC procedure in
       the DOS unit (see page 403).

   25. Are overlays still supported in 4.0?

       Overlays are not supported in 4.0; most of the reason for
       using them is gone. Version 4.0 now supports large code
       model, and it also generates much better code. This means
       that a lot of programs that used overlays to fit into 64K
       will now fit with no problem. For those who still need to
       use overlays, you can use the Exec procedure to link up
       applications or continue using version 3.0. We will
       provide an intelligent overlay manager in a future
       release.

   26. Is there any support in Turbo Pascal 4.0 for file and record
       locking?

       There's a standard variable in the SYSTEM unit called
       FileMode, which you can use to assign an open mode for use
       in all subsequent Resets. There are no record-locking
       routines implemented in the standard version, but they are
       easily implemented through MsDos calls (see page 296).

   27. Do Turbo Pascal 4.0 programs improve program execution?

       Typically programs are 30% smaller, and programs run from
       15% to 30% faster.

   28. Does Turbo 4.0 support procedure parameters?

       Turbo Pascal 4.0 does not support procedure parameters.
       However, the @ operator can be used to take the address of
       a procedure or function, which can then be passed on to
       another procedure or function. Calling via such a pointer
       is easily accomplished through an inline macro (see pages
       249 and 367).

   29. Can you use identifiers other than scalar in the case statement?

       Case statements allow the following ordinal types: Char,
       Boolean, Integer, and user defined enumeration. Basically,
       that's the same as Turbo Pascal 3.0 (see page 257).

   30. Is the runtime license policy the same as in version 3.0?

       YES, there are no royalties!

   31. What about a debugger, who has one for 4.0?

       You can use any debugger that can process .MAP files.
       TPMAP on the distribution disk converts .TPM files to .MAP
       files. You can use debuggers like Periscope, PFIX+, and
       SYMDEB to step source code and look at data (see page
       127).

   32. C has static variables, is there anything similar in 4.0?

       You can declare private global variables in the
       implementation part of a unit. Such variables are only
       visible within that unit. Like other globals, they retain
       their values across calls (see page 63 and 276).

       Typed constant declarations declared within a procedure or
       function also behave exactly like C's static variables.
       They are local in scope but since they are allocated in
       the data segment, they retain their values from call to
       call (see page 231).

   33. What Turbo Pascal 3.0 code will cause the most problems
       converting to version 4.0?

       With our UPGRADE program (Chapter 8), it's not very
       difficult to port your code to 4.0. It depends a lot on
       the type of programs you write.

       The passing of parameters on the stack is done much more
       efficiently now, so changes will have to be made to inline
       (in general). Most of the changes are voluntary: using new
       types, breaking your program into modules to take
       advantage of separate compilation. (The UPGRADE program
       has a special option to help you unitize your program too.
       It does all the "typing" for you.)

       Some stricter type-checking is performed. For example, the
       Dos unit now defines the often-seen registers record type
       (AX, BX...); MsDos and Intr now take this type. In this
       case, you can type-cast or change the type identifier and
       recompile.

   34. How do I use .BIN files provided by third-party vendors with
       4.0?

       We've included a utility on your distribution disk called
       BINOBJ.EXE, which converts binary files into .OBJ files
       that are linkable to your Turbo Pascal 4.0 programs. In
       general this will only work if the binary files contain
       data, not code. Contact your third-party vendor to see if
       they also provide .OBJ versions of their programs. (See
       BINOBJ.DOC on Disk II.)

   35. Why does TURBO try to read from another drive when I run it?

       When you leave Turbo Pascal, it saves the name and path of
       the file you were last editing in a pick list. The next
       time you load Turbo, it checks this pick list and tries to
       load the file you were last editing. If the file you were
       last editing was in another drive, Turbo will try to read
       from that drive.  This also occurs if you have installed
       another drive as your Turbo Directory (see page 165).

   36. Does Turbo Pascal 4.0 support EMS?

       Turbo Pascal 4.0 does not use EMS. You will need to need
       to write your own interface to the drivers provided with
       your EMS hardware. EMS.PAS on the distribution disk shows
       you how to access EMS memory.

   37. How can I allocate my own I/O buffer for a text file?

      You can use the procedure SetTextBuf to allocate your own
      text file buffer either in the data segment or on the heap
      (see page 481).

   38. After installing TURBO.EXE using the TINST.EXE program,
       why aren't the new settings used?

       You probably have a .TP file in the current or Turbo
       directory being loaded and the settings in the .TP file
       overrides the settings installed by TINST. Delete the .TP
       file (see page 164).

   39. Is the string size limit still 255 characters?

       Yes, it's just like in 3.0; you can write your own
       routines to handle greater than 255 character strings (see
       page 354).

   40. Can we still write to file 'Con' without changes?

       The 'Con' file is gone, but you can still write to the
       screen with a simple Write with no file variable. The file
       system has been completely redesigned to allow you to
       write your own text file device drivers. With these, you can
       implement a Pascal-like text file interface to any device,
       such as serial ports, windowing systems, memory, etc (see
       page 370).

   41. What is constant merging?

       When you use the same string constant more than once in a
       program, the compiler only saves one copy of this string.
       In the generated program, a pointer is created that
       references the one copy of this string in the generated
       .EXE file (see page 348).

   42. Have Turbo Pascal 3.0 run-time error codes changed in
       Turbo Pascal 4.0?

       Yes, error codes have changed; refer to the Appendix I in
       the reference manual.  The TURBO3 unit contains a version
       3.0 compatible IOResult function (see page 323).

   43. What books can I read that will help me with Turbo Pascal
       4.0?

       The Turbo Pascal Tutor is an excellent reference to Turbo
       Pascal. Also, Osborne/McGraw Hill has a line of books
       about Borland's products.
